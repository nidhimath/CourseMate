{
  "id": "msg_01BYHq5Js6qbdk6ZMGLa69WF",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# Chapter 8 Study Notes: NP-complete Problems\n\n## 8.1 Search Problems\n\nOver the past seven chapters we have developed algorithms for finding shortest paths and minimum spanning trees in graphs, matchings in bipartite graphs, maximum increasing subsequences, maximum flows in networks, and so on. All these algorithms are efficient, because in each case their time requirement grows as a polynomial function (such as n, n², or n³) of the size of the input.\n\nTo better appreciate such efficient algorithms, consider the alternative: In all these problems we are searching for a solution (path, tree, matching, etc.) from among an exponential population of possibilities. Indeed, n boys can be matched with n girls in n! different ways, a graph with n vertices has n^(n-2) spanning trees, and a typical graph has an exponential number of paths from s to t. All these problems could in principle be solved in exponential time by checking through all candidate solutions, one by one. But an algorithm whose running time is 2^n, or worse, is all but useless in practice. The quest for efficient algorithms is about finding clever ways to bypass this process of exhaustive search, using clues from the input in order to dramatically narrow down the search space.\n\nSo far in this book we have seen the most brilliant successes of this quest, algorithmic techniques that defeat the specter of exponentiality: greedy algorithms, dynamic programming, linear programming (while divide-and-conquer typically yields faster algorithms for problems we can already solve in polynomial time). Now the time has come to meet the quest's most embarrassing and persistent failures. We shall see some other \"search problems,\" in which again we are seeking a solution with particular properties among an exponential chaos of alternatives. But for these new problems no shortcut seems possible. The fastest algorithms we know for them are all exponential—not substantially better than an exhaustive search.\n\n### Satisfiability\n\nSATISFIABILITY, or SAT, is a problem of great practical importance, with applications ranging from chip testing and computer design to image analysis and software engineering. It is also a canonical hard problem. Here's what an instance of SAT looks like:\n\n(x ∨ y ∨ z) (x̄ ∨ ȳ) (y ∨ z̄) (z ∨ x̄) (x̄ ∨ ȳ ∨ z̄)\n\nThis is a Boolean formula in conjunctive normal form (CNF). It is a collection of clauses (the parentheses), each consisting of the disjunction (logical or, denoted ∨) of several literals, where a literal is either a Boolean variable (such as x) or the negation of one (such as x̄).\n\nA satisfying truth assignment is an assignment of false or true to each variable so that every clause contains a literal whose value is true. The SAT problem is the following: given a Boolean formula in conjunctive normal form, either find a satisfying truth assignment or else report that none exists.\n\nA search problem is specified by an algorithm C that takes two inputs, an instance I and a proposed solution S, and runs in time polynomial in |I|. We say S is a solution to I if and only if C(I, S) = true.\n\n### The Traveling Salesman Problem\n\nIn the traveling salesman problem (TSP) we are given n vertices 1, . . . , n and all n(n−1)/2 distances between them, as well as a budget b. We are asked to find a tour, a cycle that passes through every vertex exactly once, of total cost b or less—or to report that no such tour exists.\n\nNotice how we have defined the TSP as a search problem: given an instance, find a tour within the budget (or report that none exists). Our plan in this chapter is to compare and relate problems. The framework of search problems is helpful in this regard, because it encompasses optimization problems like the TSP in addition to true search problems like SAT.\n\n### Euler and Rudrata Problems\n\nEULER PATH: Given a graph, find a path that contains each edge exactly once. It follows from Euler's observation that this search problem can be solved in polynomial time.\n\nRUDRATA CYCLE: Given a graph, find a cycle that visits each vertex exactly once—or report that no such cycle exists. This problem is ominously reminiscent of the TSP, and indeed no polynomial algorithm is known for it.\n\n### Other Hard Problems\n\nINTEGER LINEAR PROGRAMMING (ILP): Given a set of linear inequalities Ax ≤ b, find a nonnegative integer n-vector x such that Ax ≤ b.\n\nZERO-ONE EQUATIONS (ZOE): Find a vector x of 0's and 1's satisfying Ax = 1, where A is an m×n matrix with 0−1 entries and 1 is the m-vector of all 1's.\n\nTHREE-DIMENSIONAL MATCHING: Given n boys, n girls, and n pets, with compatibilities specified by a set of triples, find n disjoint triples to create n harmonious households.\n\nINDEPENDENT SET: Given a graph and an integer g, find g vertices that are independent (no two of which have an edge between them).\n\nVERTEX COVER: Given a graph and a budget b, find b vertices that cover (touch) every edge.\n\nCLIQUE: Given a graph and a goal g, find a set of g vertices such that all possible edges between them are present.\n\nLONGEST PATH: Given a graph G with nonnegative edge weights and two distinguished vertices s and t, along with a goal g, find a path from s to t with total weight at least g.\n\nKNAPSACK: Given integer weights w₁, . . . , wₙ and integer values v₁, . . . , vₙ for n items, weight capacity W and goal g, find a set of items whose total weight is at most W and whose total value is at least g.\n\nSUBSET SUM: Find a subset of a given set of integers that adds up to exactly W.\n\n## 8.2 NP-complete Problems\n\n### P and NP\n\nThe class of all search problems is denoted NP.\n\nThe class of all search problems that can be solved in polynomial time is denoted P.\n\nNP stands for \"nondeterministic polynomial time,\" a term going back to the roots of complexity theory. Intuitively, it means that a solution to any search problem can be found and verified in polynomial time by a special (and quite unrealistic) sort of algorithm, called a nondeterministic algorithm.\n\nIs P ≠ NP? Most algorithms researchers think so. It is hard to believe that exponential search can always be avoided, that a simple trick will crack all these hard problems, famously unsolved for decades and centuries.\n\n### Reductions\n\nA reduction from search problem A to search problem B is a polynomial-time algorithm f that transforms any instance I of A into an instance f(I) of B, together with another polynomial-time algorithm h that maps any solution S of f(I) back into a solution h(S) of I. If f(I) has no solution, then neither does I.\n\nA search problem is NP-complete if all other search problems reduce to it.\n\nDifficulty flows in the direction of the arrow, while efficient algorithms move in the opposite direction. If even one NP-complete problem is in P, then P = NP.\n\nReductions compose: If A → B and B → C, then A → C.\n\n## 8.3 The Reductions\n\nThe search problems can be reduced to one another. As a consequence, they are all NP-complete.\n\n### Key Reductions\n\n3SAT → INDEPENDENT SET: Given a 3SAT instance, create a graph with a triangle for each clause (vertices labeled by the clause's literals), and additional edges between any two vertices that represent opposite literals. Set the goal to the number of clauses.\n\nSAT → 3SAT: Replace any clause with more than three literals (a₁ ∨ a₂ ∨ · · · ∨ aₖ) by a set of clauses using new variables y₁, y₂, etc.\n\nINDEPENDENT SET → VERTEX COVER: A set of nodes S is a vertex cover of graph G = (V, E) if and only if the remaining nodes, V − S, are an independent set of G.\n\nINDEPENDENT SET → CLIQUE: A set of nodes S is an independent set of G if and only if S is a clique of Ḡ (the complement of G).\n\n3D MATCHING → ZOE: Express 3D MATCHING as a system of 0−1 equations where each variable represents whether a triple is chosen.\n\nZOE → SUBSET SUM: Think of the columns of the matrix as numbers in base n + 1.\n\nRUDRATA CYCLE → TSP: Given a graph G = (V, E), create a TSP instance where the distance between cities u and v is 1 if {u, v} is an edge of G and 1 + α otherwise.\n\nANY PROBLEM IN NP → SAT: Any polynomial algorithm can be rendered as a circuit, and CIRCUIT SAT can be reduced to SAT."
    }
  ],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 25357,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 2095,
    "service_tier": "standard"
  }
}