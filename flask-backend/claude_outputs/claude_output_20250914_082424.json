{
  "id": "msg_01CWFveRtxKVW8T9NDmS3gyB",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# Chapter 5: Greedy algorithms\n\nA game like chess can be won only by thinking ahead: a player who is focused entirely on immediate advantage is easy to defeat. But in many other games, such as Scrabble, it is possible to do quite well by simply making whichever move seems best at the moment and not worrying too much about future consequences.\n\nThis sort of myopic behavior is easy and convenient, making it an attractive algorithmic strategy. Greedy algorithms build up a solution piece by piece, always choosing the next piece that offers the most obvious and immediate benefit. Although such an approach can be disastrous for some computational tasks, there are many for which it is optimal. Our first example is that of minimum spanning trees.\n\n## 5.1 Minimum spanning trees\n\nSuppose you are asked to network a collection of computers by linking selected pairs of them. This translates into a graph problem in which nodes are computers, undirected edges are potential links, and the goal is to pick enough of these edges that the nodes are connected. But this is not all; each link also has a maintenance cost, reflected in that edge's weight. What is the cheapest possible network?\n\nOne immediate observation is that the optimal set of edges cannot contain a cycle, because removing an edge from this cycle would reduce the cost without compromising connectivity:\n\n**Property 1** Removing a cycle edge cannot disconnect a graph.\n\nSo the solution must be connected and acyclic: undirected graphs of this kind are called trees. The particular tree we want is the one with minimum total weight, known as the minimum spanning tree. Here is its formal definition.\n\n**Input:** An undirected graph G = (V, E); edge weights we.  \n**Output:** A tree T = (V, E′), with E′ ⊆ E, that minimizes weight(T) = Σe∈E′ we.\n\n### 5.1.1 A greedy approach\n\nKruskal's minimum spanning tree algorithm starts with the empty graph and then selects edges from E according to the following rule.\n\n*Repeatedly add the next lightest edge that doesn't produce a cycle.*\n\nIn other words, it constructs the tree edge by edge and, apart from taking care to avoid cycles, simply picks whichever edge is cheapest at the moment. This is a greedy algorithm: every decision it makes is the one with the most obvious immediate advantage.\n\nThe correctness of Kruskal's method follows from a certain cut property, which is general enough to also justify a whole slew of other minimum spanning tree algorithms.\n\n### Trees\n\nA tree is an undirected graph that is connected and acyclic. Much of what makes trees so useful is the simplicity of their structure. For instance,\n\n**Property 2** A tree on n nodes has n - 1 edges.\n\nThis can be seen by building the tree one edge at a time, starting from an empty graph. Initially each of the n nodes is disconnected from the others, in a connected component by itself. As edges are added, these components merge. Since each edge unites two different components, exactly n - 1 edges are added by the time the tree is fully formed.\n\nThe converse is also true.\n\n**Property 3** Any connected, undirected graph G = (V, E) with |E| = |V| - 1 is a tree.\n\n**Property 4** An undirected graph is a tree if and only if there is a unique path between any pair of nodes.\n\n### 5.1.2 The cut property\n\nSay that in the process of building a minimum spanning tree (MST), we have already chosen some edges and are so far on the right track. Which edge should we add next? The following lemma gives us a lot of flexibility in our choice.\n\n**Cut property** Suppose edges X are part of a minimum spanning tree of G = (V, E). Pick any subset of nodes S for which X does not cross between S and V - S, and let e be the lightest edge across this partition. Then X ∪ {e} is part of some MST.\n\nA cut is any partition of the vertices into two groups, S and V - S. What this property says is that it is always safe to add the lightest edge across any cut (that is, between a vertex in S and one in V - S), provided X has no edges across the cut.\n\n### 5.1.3 Kruskal's algorithm\n\nWe are ready to justify Kruskal's algorithm. At any given moment, the edges it has already chosen form a partial solution, a collection of connected components each of which has a tree structure. The next edge e to be added connects two of these components; call them T1 and T2. Since e is the lightest edge that doesn't produce a cycle, it is certain to be the lightest edge between T1 and V - T1 and therefore satisfies the cut property.\n\n### 5.1.4 A data structure for disjoint sets\n\n**Union by rank**\n\nOne way to store a set is as a directed tree. Nodes of the tree are elements of the set, arranged in no particular order, and each has parent pointers that eventually lead up to the root of the tree. This root element is a convenient representative, or name, for the set. It is distinguished from the other elements by the fact that its parent pointer is a self-loop.\n\nIn addition to a parent pointer π, each node also has a rank that, for the time being, should be interpreted as the height of the subtree hanging from that node.\n\nBy design, the rank of a node is exactly the height of the subtree rooted at that node. This means, for instance, that as you move up a path toward a root node, the rank values along the way are strictly increasing.\n\n**Property 1** For any x, rank(x) < rank(π(x)).\n\n**Property 2** Any root node of rank k has at least 2^k nodes in its tree.\n\n**Property 3** If there are n elements overall, there can be at most n/2^k nodes of rank k.\n\nThis last observation implies, crucially, that the maximum rank is log n. Therefore, all the trees have height ≤ log n, and this is an upper bound on the running time of find and union.\n\n**Path compression**\n\nDuring each find, when a series of parent pointers is followed up to the root of a tree, we will change all these pointers so that they point directly to the root. This path compression heuristic only slightly increases the time needed for a find and is easy to code.\n\nThe benefit of this simple alteration is long-term rather than instantaneous and thus necessitates a particular kind of analysis: we need to look at sequences of find and union operations, starting from an empty data structure, and determine the average time per operation. This amortized cost turns out to be just barely more than O(1), down from the earlier O(log n).\n\n### 5.1.5 Prim's algorithm\n\nWhat the cut property tells us in most general terms is that any algorithm conforming to the following greedy schema is guaranteed to work.\n\nX = { } (edges picked so far)  \nrepeat until |X| = |V| - 1:  \n→ pick a set S ⊂ V for which X has no edges between S and V - S  \n→ let e ∈ E be the minimum-weight edge between S and V - S  \n→ X = X ∪ {e}\n\nA popular alternative to Kruskal's algorithm is Prim's, in which the intermediate set of edges X always forms a subtree, and S is chosen to be the set of this tree's vertices.\n\n## 5.2 Huffman encoding\n\nIn the MP3 audio compression scheme, a sound signal is encoded in three steps.\n\n1. It is digitized by sampling at regular intervals, yielding a sequence of real numbers s1, s2, ..., sT.\n\n2. Each real-valued sample st is quantized: approximated by a nearby number from a finite set Γ. This set is carefully chosen to exploit human perceptual limitations, with the intention that the approximating sequence is indistinguishable from s1, s2, ..., sT by the human ear.\n\n3. The resulting string of length T over alphabet Γ is encoded in binary.\n\nIt is in the last step that Huffman encoding is used. A danger with having codewords of different lengths is that the resulting encoding may not be uniquely decipherable. We will avoid this problem by insisting on the prefix-free property: no codeword can be a prefix of another codeword.\n\nAny prefix-free encoding can be represented by a full binary tree—that is, a binary tree in which every node has either zero or two children—where the symbols are at the leaves, and where each codeword is generated by a path from root to leaf, interpreting left as 0 and right as 1.\n\nIn general, how do we find the optimal coding tree, given the frequencies f1, f2, ..., fn of n symbols? To make the problem precise, we want a tree whose leaves each correspond to a symbol and which minimizes the overall length of the encoding,\n\ncost of tree = Σ(i=1 to n) fi · (depth of ith symbol in tree)\n\nThe cost of a tree is the sum of the frequencies of all leaves and internal nodes, except the root.\n\nThe first formulation of the cost function tells us that the two symbols with the smallest frequencies must be at the bottom of the optimal tree, as children of the lowest internal node. This suggests that we start constructing the tree greedily: find the two symbols with the smallest frequencies, say i and j, and make them children of a new node, which then has frequency fi + fj.\n\n## 5.3 Horn formulas\n\nIn order to display human-level intelligence, a computer must be able to perform at least some modicum of logical reasoning. Horn formulas are a particular framework for doing this, for expressing logical facts and deriving conclusions.\n\nThe most primitive object in a Horn formula is a Boolean variable, taking value either true or false. A literal is either a variable x or its negation x̄ (\"NOT x\"). In Horn formulas, knowledge about variables is represented by two kinds of clauses:\n\n1. Implications, whose left-hand side is an AND of any number of positive literals and whose right-hand side is a single positive literal.\n\n2. Pure negative clauses, consisting of an OR of any number of negative literals.\n\nGiven a set of clauses of these two types, the goal is to determine whether there is a consistent explanation: an assignment of true/false values to the variables that satisfies all the clauses. This is also called a satisfying assignment.\n\nOur strategy for solving a Horn formula is this: We start with all variables false. We then proceed to set some of them to true, one by one, but very reluctantly, and only if we absolutely have to because an implication would otherwise be violated. Once we are done with this phase and all implications are satisfied, only then do we turn to the negative clauses and make sure they are all satisfied.\n\n## 5.4 Set cover\n\nThis is a typical set cover problem. For each town x, let Sx be the set of towns within 30 miles of it. A school at x will essentially \"cover\" these other towns. The question is then, how many sets Sx must be picked in order to cover all the towns in the county?\n\n**SET COVER**  \n**Input:** A set of elements B; sets S1, ..., Sm ⊆ B  \n**Output:** A selection of the Si whose union is B.  \n**Cost:** Number of sets picked.\n\nThis problem lends itself immediately to a greedy solution:\n\nRepeat until all elements of B are covered:  \n→ Pick the set Si with the largest number of uncovered elements.\n\n**Claim** Suppose B contains n elements and that the optimal cover consists of k sets. Then the greedy algorithm will use at most k ln n sets.\n\nThe ratio between the greedy algorithm's solution and the optimal solution varies from input to input but is always less than ln n. We call this maximum ratio the approximation factor of the greedy algorithm."
    }
  ],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 17230,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 2751,
    "service_tier": "standard"
  }
}