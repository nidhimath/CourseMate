{
  "id": "msg_01KUXaFvdgVBYkmYtu9mD2Zr",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# Chapter 7 - Linear programming and reductions\n\nMany of the problems for which we want algorithms are optimization tasks: the shortest path, the cheapest spanning tree, the longest increasing subsequence, and so on. In such cases, we seek a solution that (1) satisfies certain constraints (for instance, the path must use edges of the graph and lead from s to t, the tree must touch all nodes, the subsequence must be increasing); and (2) is the best possible, with respect to some well-defined criterion, among all solutions that satisfy these constraints.\n\nLinear programming describes a broad class of optimization tasks in which both the constraints and the optimization criterion are linear functions. It turns out an enormous number of problems can be expressed in this way.\n\nGiven the vastness of its topic, this chapter is divided into several parts, which can be read separately subject to the following dependencies.\n\n## 7.1 An introduction to linear programming\n\nIn a linear programming problem we are given a set of variables, and we want to assign real values to them so as to (1) satisfy a set of linear equations and/or linear inequalities involving these variables and (2) maximize or minimize a given linear objective function.\n\n### 7.1.1 Example: profit maximization\n\nA boutique chocolatier has two products: its flagship assortment of triangular chocolates, called Pyramide, and the more decadent and deluxe Pyramide Nuit. How much of each should it produce to maximize profits? Let's say it makes x₁ boxes of Pyramide per day, at a profit of $1 each, and x₂ boxes of Nuit, at a more substantial profit of $6 apiece; x₁ and x₂ are unknown values that we wish to determine. But this is not all; there are also some constraints on x₁ and x₂ that must be accommodated (besides the obvious one, x₁, x₂ ≥ 0). First, the daily demand for these exclusive chocolates is limited to at most 200 boxes of Pyramide and 300 boxes of Nuit. Also, the current workforce can produce a total of at most 400 boxes of chocolate per day. What are the optimal levels of production?\n\nWe represent the situation by a linear program, as follows.\n\n**Objective function**\nmax x₁ + 6x₂\n\n**Constraints**\nx₁ ≤ 200\nx₂ ≤ 300  \nx₁ + x₂ ≤ 400\nx₁, x₂ ≥ 0\n\nA linear equation in x₁ and x₂ defines a line in the two-dimensional (2D) plane, and a linear inequality designates a half-space, the region on one side of the line. Thus the set of all feasible solutions of this linear program, that is, the points (x₁, x₂) which satisfy all constraints, is the intersection of five half-spaces. It is a convex polygon, shown in Figure 7.1.\n\nWe want to find the point in this polygon at which the objective function—the profit—is maximized. The points with a profit of c dollars lie on the line x₁ + 6x₂ = c, which has a slope of −1/6 and is shown in Figure 7.1 for selected values of c. As c increases, this \"profit line\" moves parallel to itself, up and to the right. Since the goal is to maximize c, we must move the line as far up as possible, while still touching the feasible region. The optimum solution will be the very last feasible point that the profit line sees and must therefore be a vertex of the polygon, as shown in the figure. If the slope of the profit line were different, then its last contact with the polygon could be an entire edge rather than a single vertex. In this case, the optimum solution would not be unique, but there would certainly be an optimum vertex.\n\nIt is a general rule of linear programs that the optimum is achieved at a vertex of the feasible region. The only exceptions are cases in which there is no optimum; this can happen in two ways:\n\n1. The linear program is infeasible; that is, the constraints are so tight that it is impossible to satisfy all of them. For instance, x ≤ 1, x ≥ 2.\n\n2. The constraints are so loose that the feasible region is unbounded, and it is possible to achieve arbitrarily high objective values. For instance,\n   max x₁ + x₂\n   x₁, x₂ ≥ 0\n\n### Solving linear programs\n\nLinear programs (LPs) can be solved by the simplex method, devised by George Dantzig in 1947. We shall explain it in more detail in Section 7.6, but briefly, this algorithm starts at a vertex, in our case perhaps (0, 0), and repeatedly looks for an adjacent vertex (connected by an edge of the feasible region) of better objective value. In this way it does hill-climbing on the vertices of the polygon, walking from neighbor to neighbor so as to steadily increase profit along the way. Here's a possible trajectory.\n\nUpon reaching a vertex that has no better neighbor, simplex declares it to be optimal and halts. Why does this local test imply global optimality? By simple geometry—think of the profit line passing through this vertex. Since all the vertex's neighbors lie below the line, the rest of the feasible polygon must also lie below this line.\n\n### More products\n\nEncouraged by consumer demand, the chocolatier decides to introduce a third and even more exclusive line of chocolates, called Pyramide Luxe. One box of these will bring in a profit of $13. Let x₁, x₂, x₃ denote the number of boxes of each chocolate produced daily, with x₃ referring to Luxe. The old constraints on x₁ and x₂ persist, although the labor restriction now extends to x₃ as well: the sum of all three variables can be at most 400. What's more, it turns out that Nuit and Luxe require the same packaging machinery, except that Luxe uses it three times as much, which imposes another constraint x₂ + 3x₃ ≤ 600. What are the best possible levels of production?\n\nHere is the updated linear program.\n\nmax x₁ + 6x₂ + 13x₃\nx₁ ≤ 200\nx₂ ≤ 300\nx₁ + x₂ + x₃ ≤ 400\nx₂ + 3x₃ ≤ 600\nx₁, x₂, x₃ ≥ 0\n\nThe space of solutions is now three-dimensional. Each linear equation defines a 3D plane, and each inequality a half-space on one side of the plane. The feasible region is an intersection of seven half-spaces, a polyhedron (Figure 7.2). Looking at the figure, can you decipher which inequality corresponds to each face of the polyhedron?\n\nA profit of c corresponds to the plane x₁ + 6x₂ + 13x₃ = c. As c increases, this profit-plane moves parallel to itself, further and further into the positive orthant until it no longer touches the feasible region. The point of final contact is the optimal vertex: (0, 300, 100), with total profit $3100.\n\nHow would the simplex algorithm behave on this modified problem? As before, it would move from vertex to vertex, along edges of the polyhedron, increasing profit steadily. A possible trajectory is shown in Figure 7.2, corresponding to the following sequence of vertices and profits:\n\n(0, 0, 0) → $0  \n(200, 0, 0) → $200  \n(200, 200, 0) → $1400  \n(200, 0, 200) → $2800  \n(0, 300, 100) → $3100\n\nFinally, upon reaching a vertex with no better neighbor, it would stop and declare this to be the optimal point. Once again by basic geometry, if all the vertex's neighbors lie on one side of the profit-plane, then so must the entire polyhedron.\n\n### A magic trick called duality\n\nHere is why you should believe that (0, 300, 100), with a total profit of $3100, is the optimum: Look back at the linear program. Add the second inequality to the third, and add to them the fourth multiplied by 4. The result is the inequality x₁ + 6x₂ + 13x₃ ≤ 3100.\n\nDo you see? This inequality says that no feasible solution (values x₁, x₂, x₃ satisfying the constraints) can possibly have a profit greater than 3100. So we must indeed have found the optimum! The only question is, where did we get these mysterious multipliers (0, 1, 1, 4) for the four inequalities?\n\nIn Section 7.4 we'll see that it is always possible to come up with such multipliers by solving another LP! Except that (it gets even better) we do not even need to solve this other LP, because it is in fact so intimately connected to the original one—it is called the dual—that solving the original LP solves the dual as well! But we are getting far ahead of our story.\n\nWhat if we add a fourth line of chocolates, or hundreds more of them? Then the problem becomes high-dimensional, and hard to visualize. Simplex continues to work in this general setting, although we can no longer rely upon simple geometric intuitions for its description and justification. We will study the full-fledged simplex algorithm in Section 7.6.\n\nIn the meantime, we can rest assured in the knowledge that there are many professional, industrial-strength packages that implement simplex and take care of all the tricky details like numeric precision. In a typical application, the main task is therefore to correctly express the problem as a linear program. The package then takes care of the rest.\n\nWith this in mind, let's look at a high-dimensional application.\n\n### 7.1.2 Example: production planning\n\nThis time, our company makes handwoven carpets, a product for which the demand is extremely seasonal. Our analyst has just obtained demand estimates for all months of the next calendar year: d₁, d₂, ..., d₁₂. As feared, they are very uneven, ranging from 440 to 920.\n\nHere's a quick snapshot of the company. We currently have 30 employees, each of whom makes 20 carpets per month and gets a monthly salary of $2,000. We have no initial surplus of carpets.\n\nHow can we handle the fluctuations in demand? There are three ways:\n\n1. Overtime, but this is expensive since overtime pay is 80% more than regular pay. Also, workers can put in at most 30% overtime.\n\n2. Hiring and firing, but these cost $320 and $400, respectively, per worker.\n\n3. Storing surplus production, but this costs $8 per carpet per month. We currently have no stored carpets on hand, and we must end the year without any carpets stored.\n\nThis rather involved problem can be formulated and solved as a linear program!\n\nA crucial first step is defining the variables.\n\nwᵢ = number of workers during ith month; w₀ = 30.\nxᵢ = number of carpets made during ith month.\noᵢ = number of carpets made by overtime in month i.\nhᵢ, fᵢ = number of workers hired and fired, respectively, at beginning of month i.\nsᵢ = number of carpets stored at end of month i; s₀ = 0.\n\nAll in all, there are 72 variables (74 if you count w₀ and s₀).\n\nWe now write the constraints. First, all variables must be nonnegative:\n\nwᵢ, xᵢ, oᵢ, hᵢ, fᵢ, sᵢ ≥ 0, i = 1, ..., 12.\n\nThe total number of carpets made per month consists of regular production plus overtime:\n\nxᵢ = 20wᵢ + oᵢ\n\n(one constraint for each i = 1, ..., 12). The number of workers can potentially change at the start of each month:\n\nwᵢ = wᵢ₋₁ + hᵢ - fᵢ.\n\nThe number of carpets stored at the end of each month is what we started with, plus the number we made, minus the demand for the month:\n\nsᵢ = sᵢ₋₁ + xᵢ - dᵢ.\n\nAnd overtime is limited:\n\noᵢ ≤ 6wᵢ.\n\nFinally, what is the objective function? It is to minimize the total cost:\n\nmin 2000 Σᵢ wᵢ + 320 Σᵢ hᵢ + 400 Σᵢ fᵢ + 8 Σᵢ sᵢ + 180 Σᵢ oᵢ,\n\na linear function of the variables. Solving this linear program by simplex should take less than a second and will give us the optimum business strategy for our company.\n\nWell, almost. The optimum solution might turn out to be fractional; for instance, it might involve hiring 10.6 workers in the month of March. This number would have to be rounded to either 10 or 11 in order to make sense, and the overall cost would then increase correspondingly. In the present example, most of the variables take on fairly large (double-digit) values, and thus rounding is unlikely to affect things too much. There are other LPs, however, in which rounding decisions have to be made very carefully in order to end up with an integer solution of reasonable quality.\n\nIn general, there is a tension in linear programming between the ease of obtaining fractional solutions and the desirability of integer ones. As we shall see in Chapter 8, finding the optimum integer solution of an LP is an important but very hard problem, called integer linear programming.\n\n### 7.1.3 Example: optimum bandwidth allocation\n\nNext we turn to a miniaturized version of the kind of problem a network service provider might face.\n\nSuppose we are managing a network whose lines have the bandwidths shown in Figure 7.3, and we need to establish three connections: between users A and B, between B and C, and between A and C. Each connection requires at least two units of bandwidth, but can be assigned more. Connection A–B pays $3 per unit of bandwidth, and connections B–C and A–C pay $2 and $4, respectively.\n\nEach connection can be routed in two ways, a long path and a short path, or by a combination: for instance, two units of bandwidth via the short route, one via the long route. How do we route these connections to maximize our network's revenue?\n\nThis is a linear program. We have variables for each connection and each path (long or short); for example, x_{AB} is the short-path bandwidth allocated to the connection between A and B, and x'_{AB} the long-path bandwidth for this same connection. We demand that no edge's bandwidth is exceeded and that each connection gets a bandwidth of at least 2 units.\n\nmax 3x_{AB} + 3x'_{AB} + 2x_{BC} + 2x'_{BC} + 4x_{AC} + 4x'_{AC}\n\nx_{AB} + x'_{AB} + x_{BC} + x'_{BC} ≤ 10    [edge (b, B)]\nx_{AB} + x'_{AB} + x_{AC} + x'_{AC} ≤ 12    [edge (a, A)]\nx_{BC} + x'_{BC} + x_{AC} + x'_{AC} ≤ 8     [edge (c, C)]\nx_{AB} + x'_{BC} + x'_{AC} ≤ 6              [edge (a, b)]\nx'_{AB} + x_{BC} + x'_{AC} ≤ 13             [edge (b, c)]\nx'_{AB} + x'_{BC} + x_{AC} ≤ 11             [edge (a, c)]\nx_{AB} + x'_{AB} ≥ 2\nx_{BC} + x'_{BC} ≥ 2\nx_{AC} + x'_{AC} ≥ 2\nx_{AB}, x'_{AB}, x_{BC}, x'_{BC}, x_{AC}, x'_{AC} ≥ 0\n\nEven a tiny example like this one is hard to solve on one's own (try it!), and yet the optimal solution is obtained instantaneously via simplex:\n\nx_{AB} = 0, x'_{AB} = 7, x_{BC} = x'_{BC}"
    }
  ],
  "stop_reason": "max_tokens",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 28219,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 4000,
    "service_tier": "standard"
  }
}