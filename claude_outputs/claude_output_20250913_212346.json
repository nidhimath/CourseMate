{
  "id": "msg_015ZDEJhrS1ZjvFVUgT4GpFd",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# CS162 Operating Systems and Systems Programming Study Notes\n\n## Lecture 14: Virtual Memory\n\n### Virtualizing Memory\nOperating systems provide virtual memory as part of virtualizing system resources. Process abstraction includes:\n→ Memory (address space) - stores code, data, stack, heap\n→ CPU Registers - Program Counter, Stack Pointer, regular registers  \n→ IO information - open files and other resources\n\n### Memory Virtualization Objectives\n→ **Isolation** - processes cannot access each other's memory\n→ **Flexibility** - processes can use memory as needed\n→ **Infinite Resources** - illusion of unlimited memory\n\nOS interposes on memory access through hardware translation support. Hardware accelerates common case; uncommon cases trap to OS.\n\n### Memory Addresses  \nMemory addresses refer to byte locations. With K bits, can address 2^K unique locations.\n→ 32-bit addresses: 2^32 = 4,294,967,296 bytes\n→ 64-bit addresses: 2^64 = extremely large address space\n\n### Memory Protection Mechanisms\n\n**1.1 Uniprogramming**\nApplication runs at same physical memory location. No protection - application can access any physical address. Gives illusion of dedicated machine by providing reality of dedicated machine.\n\n**1.2 Memory Translation Through Relocation**  \nLoader/linker adjusts addresses when program loaded into memory. No protection - bugs in any program can crash other programs or OS.\n\n**1.3 Base & Bound**\nHardware registers provide protection:\n→ Base register: starting address of process memory\n→ Bound register: limit of process memory\n→ CPU checks: physical address must be between Base and Base+Bound\n\nLimitations:\n→ No expandable memory (static allocation)\n→ No memory sharing between processes\n→ Non-relative memory addresses\n→ External fragmentation (cannot relocate programs)\n→ Internal fragmentation (address space must be contiguous)\n\n**1.4 Base & Bound With Hardware Relocation**\nPrograms compiled as if loaded at address zero. Hardware translates:\nphysical address = virtual address + base\n\nMemory Management Unit (MMU) performs virtual to physical address translation.\n\n**1.5 Segmentation**\nCreates base and bounds pair per logical segment (code, data, heap, stack). Each segment placed independently in memory.\n\nImplementation uses segment map in processor:\n→ Segment number mapped to base/limit pair  \n→ Virtual address = [Segment #][Offset]\n→ Physical address = Base[Segment #] + Offset\n\nPros:\n→ Minimal hardware requirements\n→ Supports sparse address spaces\n→ Avoids internal fragmentation\n\nCons: \n→ External fragmentation still a problem\n→ Must fit variable-sized chunks into physical memory\n\n## Lecture 15: Virtual Memory (2)\n\n### Paging\nDivides logical address space into fixed-sized pages and physical memory into page frames.\n\nVirtual address format: [Virtual Page #][Offset]\n→ Virtual Page # specifies which page\n→ Offset specifies location within page\n\n### Page Tables\nStore virtual-to-physical address translations. One page table per process, stored in memory. Page Table Base Register (PTBR) points to table.\n\nTranslation process:\n1. Extract virtual page number (first p bits)\n2. Look up physical frame number in page table\n3. Extract offset (last o bits)  \n4. Combine: physical address = frame # × page size + offset\n\n### Page Table Entry (PTE) - 32 bits\nContains:\n→ Page Frame Number (20 bits)\n→ Control bits (12 bits):\n  - P: Present/valid\n  - W: Writeable\n  - U: User accessible\n  - A: Accessed recently\n  - D: Dirty (modified)\n  - Protection and caching bits\n\n### PTE Capabilities\n→ **Demand Paging**: Keep only active pages in memory\n→ **Copy-on-Write**: Share pages between processes, copy when modified\n→ **Zero Fill On Demand**: Allocate zeroed pages on first use\n→ **Data Breakpoints**: Mark pages read-only for debugging\n\n### Page Sharing\nProcesses map virtual pages to same physical frame. Used for:\n→ Kernel region shared across processes\n→ Multiple processes running same binary\n→ Shared memory segments\n\n### Multi-Level Page Tables\nAddresses page table size problem through hierarchy:\n\n**Two-Level Paging**:\nVirtual address: [Outer Page #][Inner Page #][Offset]\n→ Outer table points to inner tables\n→ Inner tables point to physical frames\n→ Can mark entire regions invalid to save space\n\n**x86 64-bit**: Four-level page tables with 48-bit virtual addresses\n\n### Inverted Page Tables\nSingle table with entry per physical page. Contains process ID + virtual page mapping. Size proportional to physical memory, not virtual.\n\n### Translation Lookaside Buffer (TLB)\nHardware cache for virtual-to-physical translations. Exploits locality:\n→ **Temporal locality**: Recently accessed pages likely accessed again\n→ **Spatial locality**: Nearby pages likely accessed together\n\nWithout TLB, each memory access requires multiple page table lookups. TLB provides cached end-to-end translation result.\n\n### Address Translation Performance\nAverage Memory Access Time (AMAT) = (Hit Rate × Hit Time) + (Miss Rate × Miss Time)\n\nTLB dramatically improves translation speed by caching recent translations.\n\n### Memory Hierarchy Integration\nTranslation occurs between processor and main memory:\n→ Core → Cache(s) → MMU (with TLB) → Physical Memory\n→ Page tables stored in main memory (possibly cached)\n\n### Paging Limitations\n→ **Space overhead**: Large page tables for 64-bit address spaces\n→ **Time overhead**: Multiple memory accesses for translation\n→ **Internal fragmentation**: Unused space within pages\n\nSolutions involve combination of multi-level tables, TLBs, and inverted tables to balance space/time tradeoffs."
    }
  ],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 16866,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 1393,
    "service_tier": "standard"
  }
}