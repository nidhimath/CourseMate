{
  "id": "msg_011BsPgkJ6UAANbzyKDDZARr",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# CS162: Operating Systems and Systems Programming\n## Lecture 7 & 8: Concurrency\n\n### 7.1 Introduction to Concurrency\n\n**→ Correctness with Concurrency**\n\nThreaded programs must work for all interleavings of thread instruction sequences. Cooperating threads are inherently non-deterministic and non-reproducible, making them extremely difficult to debug unless carefully designed.\n\n### 7.2 The Milk Buying Problem\n\n**→ Problem Statement**\n\nTwo people need to coordinate buying milk to avoid purchasing too much while ensuring someone buys it when needed.\n\n**x Time-Based Example:**\n\nAt 3:00, Person A checks fridge - out of milk\nAt 3:05, Person A leaves for store\nAt 3:10, Person A arrives at store; Person B checks fridge - out of milk\nAt 3:15, Person A buys milk; Person B leaves for store\nAt 3:20, Person A arrives home with milk; Person B arrives at store\nAt 3:25, Person B buys milk\nAt 3:30, Person B arrives home with milk\n\nResult: Too much milk purchased due to lack of coordination.\n\n**→ Desired Correctness Properties**\n\n1. Never more than one person buys milk (mutual exclusion)\n2. Someone buys milk if needed (progress)\n\n### 7.3 Solution Attempts Using Atomic Operations\n\n**→ Solution #1: Simple Note**\n\n```\nif (noMilk) {\n   if (noNote) {\n      leave Note;\n      buy milk;\n      remove Note;\n   }\n}\n```\n\n**x Problem:** Thread can be context switched after checking but before buying milk. This intermittent failure makes debugging extremely difficult.\n\n**→ Solution #1½: Note First**\n\n```\nleave Note;\nif (noMilk) {\n   if (noNote) {\n      buy milk;\n   }\n}\nremove Note;\n```\n\n**x Problem:** With computers, no one ever buys milk - both threads see note and skip buying.\n\n**→ Solution #2: Labeled Notes**\n\nThread A and Thread B each leave their own notes before checking for the other's note.\n\n**x Problem:** Possible for neither thread to buy milk if context switches occur at exactly wrong times.\n\n**→ Solution #3: Asymmetric Solution**\n\nThread A:\n```\nleave note A;\nwhile (note B) { //X\n   do nothing;\n}\nif (noMilk) {\n   buy milk;\n}\nremove note A;\n```\n\nThread B:\n```\nleave note B;\nif (noNote A) { //Y\n   if (noMilk) {\n      buy milk;\n   }\n}\nremove note B;\n```\n\nThis solution is correct under sequential consistency assumptions but is unsatisfactory due to complexity, asymmetry between threads, and busy-waiting.\n\n### 7.4 Hardware Support for Synchronization\n\n**→ Lock-Based Solution**\n\nUsing acquire() and release() operations:\n\n```\nacquire(&milklock);\nif (nomilk)\n   buy milk;\nrelease(&milklock);\n```\n\n**→ Implementation Approaches**\n\n**1.1 Disabling Interrupts**\n\nSimple but problematic:\n- Critical sections might be arbitrarily long\n- Doesn't work on multiprocessors\n- Can miss important I/O events\n\nSmarter approach with short critical sections:\n```\nAcquire() {\n   disable interrupts;\n   if (value == BUSY) {\n      put thread on wait queue;\n      Go to sleep();\n   } else {\n      value = BUSY;\n   }\n   enable interrupts;\n}\n```\n\n**1.2 Atomic Read-Modify-Write Instructions**\n\nHardware provides atomic operations:\n\n**test&set:**\n```\ntest&set(&address) {\n   result = M[address];\n   M[address] = 1;\n   return result;\n}\n```\n\n**compare&swap:**\n```\ncompare&swap(&address, reg1, reg2) {\n   if (reg1 == M[address]) {\n      M[address] = reg2;\n      return success;\n   } else {\n      return failure;\n   }\n}\n```\n\n### 7.5 Lock Implementation Using Hardware Support\n\n**→ Simple Busy-Waiting Lock**\n\n```\nacquire(int *thelock) {\n   while (test&set(thelock));\n}\n\nrelease(int *thelock) {\n   *thelock = 0;\n}\n```\n\n**x Problem:** Busy-waiting wastes CPU cycles and causes cache ping-ponging on multiprocessors.\n\n**→ Better Lock with Sleep/Wake**\n\nOnly busy-wait to atomically check lock value, then sleep if needed:\n\n```\nacquire(int *thelock) {\n   while (test&set(guard));\n   if (*thelock == BUSY) {\n      put thread on wait queue;\n      go to sleep() & guard = 0;\n   } else {\n      *thelock = BUSY;\n      guard = 0;\n   }\n}\n```\n\n### 7.6 Linux futex\n\nFast Userspace Mutex provides kernel sleep functionality:\n\n- FUTEX_WAIT: Sleep if condition holds\n- FUTEX_WAKE: Wake up waiting threads\n\nAllows syscall-free operation in uncontended case while falling back to kernel support when needed.\n\n### 8.1 Producer-Consumer Problem\n\n**→ Problem Definition**\n\nProducers put items into shared buffer, consumers remove them. Need synchronization to:\n- Prevent producer from adding to full buffer\n- Prevent consumer from removing from empty buffer\n- Protect buffer integrity\n\n### 8.2 Semaphores\n\n**→ Definition**\n\nNon-negative integer value with atomic operations:\n- P() or Down(): Wait for positive value, then decrement\n- V() or Up(): Increment value, wake waiting thread\n\n**→ Two Uses**\n\n**1.1 Mutual Exclusion (initial value = 1)**\n```\nsemaP(&mysem);\n// Critical section\nsemaV(&mysem);\n```\n\n**1.2 Scheduling Constraints (initial value = 0)**\n\nFor thread synchronization and signaling.\n\n**→ Bounded Buffer with Semaphores**\n\n```\nSemaphore fullSlots = 0;\nSemaphore emptySlots = bufSize;\nSemaphore mutex = 1;\n\nProducer(item) {\n   semaP(&emptySlots);\n   semaP(&mutex);\n   Enqueue(item);\n   semaV(&mutex);\n   semaV(&fullSlots);\n}\n\nConsumer() {\n   semaP(&fullSlots);\n   semaP(&mutex);\n   item = Dequeue();\n   semaV(&mutex);\n   semaV(&emptySlots);\n   return item;\n}\n```\n\n### 8.3 Monitors\n\n**→ Components**\n\nMonitor consists of:\n- Lock for mutual exclusion\n- Condition variables for scheduling constraints\n\n**→ Condition Variable Operations**\n\n- Wait(&lock): Atomically release lock and sleep\n- Signal(): Wake one waiter\n- Broadcast(): Wake all waiters\n\n**→ Mesa vs Hoare Semantics**\n\nMesa (most common):\n- Signaler keeps lock and processor\n- Waiter placed on ready queue\n- Must recheck condition with while loop\n\nHoare:\n- Signaler transfers lock/CPU to waiter\n- Waiter runs immediately\n\n**→ Bounded Buffer with Monitor**\n\n```\nProducer(item) {\n   acquire(&buf_lock);\n   while (buffer full) {\n      cond_wait(&isNotFull, &buf_lock);\n   }\n   enqueue(item);\n   cond_signal(&isNotEmpty);\n   release(&buf_lock);\n}\n\nConsumer() {\n   acquire(&buf_lock);\n   while (buffer empty) {\n      cond_wait(&isNotEmpty, &buf_lock);\n   }\n   item = dequeue();\n   cond_signal(&isNotFull);\n   release(&buf_lock);\n   return item;\n}\n```\n\n### 8.4 Readers/Writers Problem\n\n**→ Problem Statement**\n\nMultiple readers can access database simultaneously, but writers need exclusive access.\n\n**→ State Variables**\n\n- AR: Active readers\n- WR: Waiting readers  \n- AW: Active writers\n- WW: Waiting writers\n\n**→ Implementation**\n\nReader checks if safe to read (no active/waiting writers), increments active readers, accesses database, then signals waiting writer if last reader.\n\nWriter checks if safe to write (no active readers/writers), gets exclusive access, then signals waiting writers or broadcasts to waiting readers.\n\n### 8.5 Language Support\n\n**→ C++**\n\nLock guards with RAII pattern:\n```\nstd::lock_guard<std::mutex> lock(global_mutex);\n// Automatically released when out of scope\n```\n\n**→ Python**\n\nwith statement:\n```\nwith lock:\n   some_var += 1\n   # Automatically released\n```\n\n**→ Java**\n\nsynchronized keyword:\n```\npublic synchronized void deposit(int amount) {\n   balance += amount;\n}\n```\n\nBuilt-in monitor support with wait(), notify(), notifyAll()."
    }
  ],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 29400,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 2188,
    "service_tier": "standard"
  }
}