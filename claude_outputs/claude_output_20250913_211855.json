{
  "id": "msg_01KAwKyYjWSN1QPgokK3LaYu",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# CS162: Operating Systems and Systems Programming\n\n## 5.1 File Descriptors\n\n→ **Introduction to File Descriptors**\n\nAll input/output in Linux follows a uniform interface. UNIX offers the same IO interface for all device Input/Output, reading/writing files, interprocess communication, printers, mouse, disk, pipes, and sockets. Everything is a file!\n\n→ **Core Tenants of UNIX/IO Interface**\n\nx **Uniformity** - Same set of system calls (open, read, write, close)\n\nx **Open Before Use** - Must explicitly open file/device/channel\n\nx **Byte-Oriented** - All devices, even block devices, are accessed through byte arrays\n\nx **Kernel Buffered Reads/Writes** - Data is buffered at kernel to decouple internals from application\n\nx **Explicit Close** - Must explicitly close resource\n\n→ **Understanding the File Descriptor**\n\nA file descriptor is a number that uniquely identifies an open IO resource in the OS. It's another index! File descriptors index into a per-process file descriptor table.\n\nEach process maintains its own file descriptor table as part of its process control structure (struct proc in xv6). The file descriptor table contains an array of pointers to open file descriptions (struct file *ofile[NOFILE]).\n\n→ **Table of Open File Description**\n\nEach FD points to an open file description in a system-wide table of open files containing:\n- File offset\n- File access mode (from open())\n- File status flags (from open())\n- Reference to physical location (inode)\n- Number of times opened\n\n→ **Manipulating File Descriptors**\n\n**Opening and Creating Files:**\n```c\nint open(const char *filename, int flags, [mode_t mode]);\nint creat(const char *filename, mode_t mode);\nint close(int filedes);\n```\n\nAll files explicitly opened via open or create. Return the lowest-numbered file descriptor not currently open for the process. Creates new open file description. Close closes a file descriptor, so that it no longer refers to any file and may be reused.\n\n**Reading and Writing:**\n```c\nssize_t read(int filedes, void *buffer, size_t maxsize);\nssize_t write(int filedes, const void *buffer, size_t size);\noff_t lseek(int filedes, off_t offset, int whence);\n```\n\n→ **Example: File Descriptor Operations**\n\nWhen a process opens a file, it gets the lowest available file descriptor. The file descriptor points to an entry in the global open file description table. Multiple operations on the same file descriptor share the same file offset, which advances with each read/write operation.\n\n→ **Duplicating File Descriptors**\n\nThe dup() system call creates a copy of a file descriptor. Both file descriptors point to the same open file description, sharing the file offset and other attributes. Changes through one descriptor affect the other.\n\n→ **Forking and File Descriptors**\n\nWhen a process forks, the child process inherits copies of the parent's file descriptors. Both parent and child file descriptors point to the same entries in the global open file description table.\n\n→ **Interprocess Communication: Pipes**\n\nPipes implement a queue abstraction, implemented as a kernel buffer with two file descriptors - one for writing and one for reading. The pipe() system call allocates two new file descriptors: writes to fileds[1] read from fileds[0]. Pipes block if full or empty.\n\nAfter last \"write\" descriptor is closed, pipe is effectively closed - reads return only EOF. After last \"read\" descriptor is closed, writes generate SIGPIPE signals.\n\n→ **IPC Across Machines: Sockets**\n\nSockets are an abstraction of two queues, one in each direction. Can read or write to either end. Used for communication between multiple processes on different machines. File descriptors obtained via socket/bind/connect/listen/accept. Still a file - same API/datastructures as files and pipes.\n\n## 5.2 OS Library\n\n→ **Purpose of OS Library**\n\nThe OS Library (libc) acts as glue, providing a set of common services between applications and the OS kernel. It serves two main purposes:\n\nx **Improve Programming API** - Minimizes glue code, simulates additional functionality, provides \"High Level C API\"\n\nx **Performance** - Minimizes cost of syscalls\n\n→ **From File Descriptors to FILE***\n\nFILE* is an OS Library wrapper for manipulating explicit files. Internally contains:\n- File descriptor (from call to open)\n- Buffer (array)\n- Lock (in case multiple threads use the FILE concurrently)\n\nFILE* API operates on streams - unformatted sequences of bytes (text or binary data), with a position.\n\n```c\nFILE *fopen(const char *filename, const char *mode);\nint fclose(FILE *fp);\n```\n\n→ **C High-Level File API**\n\nCharacter oriented:\n```c\nint fputc(int c, FILE *fp);\nint fputs(const char *s, FILE *fp);\nint fgetc(FILE *fp);\nchar *fgets(char *buf, int n, FILE *fp);\n```\n\nBlock oriented:\n```c\nsize_t fread(void *ptr, size_t size_of_elements, \n             size_t number_of_elements, FILE *a_file);\nsize_t fwrite(const void *ptr, size_t size_of_elements,\n              size_t number_of_elements, FILE *a_file);\n```\n\nFormatted:\n```c\nint fprintf(FILE *restrict stream, const char *restrict format, ...);\nint fscanf(FILE *restrict stream, const char *restrict format, ...);\n```\n\n→ **Buffered IO**\n\nFILE* maintains a per-file user-level buffer. Write calls write to buffer - system flushes buffer to disk when full (or on special character). Read calls read from buffer - system reads from disk when buffer empty. Operations on file descriptors are unbuffered & visible immediately.\n\n→ **Performance Benefits**\n\nSyscalls are 25x more expensive than function calls (~100 ns). Buffering minimizes the number of syscalls and amount copied. FILE* operations can be 50x faster than direct syscall operations.\n\n→ **Buffering Pitfalls**\n\nIf not careful, buffering can cause inconsistencies. Must use fflush() to ensure data is written. Avoid mixing FILE* and file descriptors - fread() reads a big chunk of file into user-level buffer, potentially reading ahead of what's requested.\n\n## 5.3 Threads and the Thread API\n\n→ **What is a Thread?**\n\nA single execution sequence that represents a separately schedulable task. Virtualizes the processor - each thread runs on a dedicated virtual processor (with variable speed). Infinitely many such processors. Threads enable users to define each task with sequential code but run each task concurrently.\n\n→ **Why Do We Need Threads?**\n\nx **Natural Program Structure** - Simultaneously update screen, fetch new data from network, receive keyboard input\n\nx **Exploiting Parallelism** - Split unit of work into n tasks and process tasks in parallel on multiple cores\n\nx **Responsiveness** - High priority work should not be delayed by low priority work\n\nx **Masking IO Latency** - Continue to do useful work on separate thread while blocked on IO\n\n→ **Thread ≠ Process**\n\nProcesses define the granularity at which the OS offers isolation and protection. Threads capture concurrent sequences of computation. Processes consist of one or more threads!\n\n→ **Thread Requirements**\n\n**No protection** - Threads inside the same process are not isolated from each other\n\n**Individual execution** - Threads execute disjoint instruction streams, need own execution context\n\n**Share an address space** - Share IO state (FDs)\n\n**Individual stack** - Each thread needs its own stack, register state (including EIP, ESP, EBP)\n\n→ **Thread Implementation**\n\nEach process has a PCB containing code, data, heap, and file descriptor table. Each thread within the process has its own TCB (Thread Control Block) containing saved registers, stack, and metadata.\n\n→ **User Threads vs Kernel Threads**\n\n**User Threads:**\n- One PCB for the process\n- Each thread has own TCB stored in heap of process\n- Threads in user-space only, invisible to kernel\n\n**Kernel Threads:**\n- Each thread has own TCB\n- Each thread individually schedulable\n- Requires mode switch to switch threads\n\n→ **Threads in Linux**\n\nEverything is a thread (task_struct). Scheduler only schedules task_struct. Processes are containers in which threads execute.\n\nTo fork a process: Invoke clone(...)\nTo create a thread: Invoke clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)\n\n→ **pThreads API**\n\n```c\nint pthread_create(pthread_t *thread, ... \n                   void *(*start_routine)(void*), void *arg);\nvoid pthread_exit(void *value_ptr);\nint pthread_yield();\nint pthread_join(pthread_t thread, void **value_ptr);\n```\n\n→ **Fork-Join Pattern**\n\nMain thread creates (forks) collection of sub-threads passing them args to work on, and then joins with them, collecting results.\n\n→ **Concurrency Challenges**\n\nProtection is at process level. Threads not isolated. Share an address space. Non-deterministic interleaving of threads leads to race conditions.\n\n# CS162: Operating Systems and Systems Programming\n\n## 6.1 Concurrency\n\n→ **What is a Thread?**\n\nA single execution sequence that represents a separately schedulable task. Virtualizes the processor - each thread runs on a dedicated virtual processor (with variable speed). Infinitely many such processors. Threads let users define each task with sequential code but run each task concurrently.\n\n→ **Thread Architecture**\n\nNo protection - Threads inside the same process are not isolated from each other\n\nIndividual execution - Threads execute disjoint instruction streams, need own execution context  \n\nShare an address space & share IO state (FDs)\n\nIndividual stack, register state (including EIP, ESP, EBP)\n\n→ **Threads in Linux**\n\nEverything is a thread (task_struct). Scheduler only schedules task_struct. Processes are containers in which threads execute.\n\nTo fork a process: Invoke clone(...)\nTo create a thread: Invoke clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)\n\n→ **pThreads API**\n\n```c\nint pthread_create(pthread_t *thread, ...\n                   void *(*start_routine)(void*), void *arg);\nvoid pthread_exit(void *value_ptr);\nint pthread_join(pthread_t thread, void **value_ptr);\nint pthread_yield();\n```\n\n→ **Fork-Join Pattern**\n\nMain thread creates (forks) multiple sub-threads, passing them args to work on, and then joins with them, collecting results.\n\n## 6.2 Concurrency Challenges\n\n→ **Race Conditions**\n\nProtection is at process level. Threads not isolated. Share an address space. Non-deterministic interleaving of threads causes unpredictable results.\n\n→ **Multiprocessing vs Multiprogramming**\n\n**Multiprocessing** - multiple CPUs  \n**Multiprogramming** - multiple jobs or processes  \n**Multithreading** - multiple threads per process\n\nScheduler is free to run threads in any order. Can choose to run each thread to completion or time-slice in big or small chunks.\n\n→ **Example: ATM Bank Server**\n\nService a set of requests without corrupting database or handing out too much money. \n\nWithout threads, would need event-driven style with complex state management. Threads yield overlapped I/O and computation without \"deconstructing\" code into non-blocking fragments. One thread per request allows requests to proceed to completion, blocking as required.\n\n→ **The Race Condition Problem**\n\nShared state can get corrupted when multiple threads access it concurrently:\n\nThread 1:\n```\nload r1, acct->balance\nadd r1, amount1\nstore r1, acct->balance\n```\n\nThread 2:\n```\nload r1, acct->balance\nadd r1, amount2\nstore r1, acct->balance\n```\n\nDifferent interleavings produce different results.\n\n## 6.3 Atomic Operations and Synchronization\n\n→ **Atomic Operations**\n\nAn operation that always runs to completion, or not at all. It is indivisible: cannot be stopped in the middle, and state cannot be modified by someone else in the middle. Fundamental building block - without atomic operations, threads have no way to work together.\n\nOn most machines, memory references and assignments (loads and stores) of words are atomic. Many instructions are not atomic (e.g., double-precision floating point store).\n\n→ **Synchronization Definitions**\n\n**Synchronization** - Using atomic operations to ensure cooperation between threads\n\n**Mutual Exclusion** - Ensuring that only one thread does a particular thing at a time\n\n**Critical Section** - Piece of code that only one thread can execute at once\n\n→ **Locks**\n\nPrevents someone from doing something. Lock() before entering critical section and before accessing shared data. Unlock() when leaving, after accessing shared data. Wait if locked. All synchronization involves waiting.\n\n→ **API for Locks**\n\nAllocation and initialization:\n```c\nstruct Lock mylock;\n// or\npthread_mutex_t mylock;\nlock_init(&mylock);\n// or\nmylock = PTHREAD_MUTEX_INITIALIZER;\n```\n\nAtomic operations:\n```c\nacquire(&mylock); // wait until lock is free; then mark as busy\nrelease(&mylock); // mark lock as free\n```\n\n→ **Fix Banking Problem with Locks**\n\n```c\nDeposit(acctId, amount) {\n   acquire(&mylock);      // Wait if someone else in critical section\n   acct = GetAccount(actId);\n   acct->balance += amount;\n   StoreAccount(acct);\n   release(&mylock);      // Release someone into critical section\n}\n```\n\nThreads serialized by lock through critical section. Only one thread at a time.\n\n→ **Correctness Requirements**\n\nThreaded programs must work for all interleavings of thread instruction sequences. Cooperating threads inherently non-deterministic and non-reproducible. Really hard to debug unless carefully designed!\n\n## 6.4 The \"Too Much Milk\" Problem\n\n→ **Problem Statement**\n\nTwo people need to coordinate buying milk. Never more than one person buys. Someone buys if needed.\n\n→ **Solution Attempts**\n\n**Solution #1** - Leave note before buying: Fails because thread can be context switched after checking but before leaving note.\n\n**Solution #1½** - Leave note before checking: Results in no one ever buying milk.\n\n**Solution #2** - Labeled notes: Can lead to neither thread buying milk due to unfortunate context switches. This kind of lockup is called \"starvation.\"\n\n→ **Solution #3 (Working Solution)**\n\nThread A:\n```\nleave note A;\nwhile (note B) {\n   do nothing;\n}\nif (noMilk) {\n   buy milk;\n}\nremove note A;\n```\n\nThread B:\n```\nleave note B;\nif (noNote A) {\n   if (noMilk) {\n      buy milk;\n   }\n}\nremove note B;\n```\n\nBoth can guarantee that either it is safe to buy, or other will buy. Works but is unsatisfactory - complex, asymmetric code, busy-waiting.\n\n→ **Solution #4 (With Locks)**\n\n```c\nacquire(&milklock);\nif (nomilk)\n   buy milk;\nrelease(&milklock);\n```\n\nSimple and symmetric solution using atomic lock operations.\n\n→ **Hardware Support for Synchronization**\n\nImplement various higher-level synchronization primitives using atomic operations:\n\n**Hardware:** Load/Store, Disable Ints, Test&Set, Compare&Swap\n\n**Higher-level API:** Locks, Semaphores, Monitors, Send/Receive\n\n**Programs:** Shared Programs"
    }
  ],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 19192,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 3799,
    "service_tier": "standard"
  }
}