{
  "id": "msg_014vypJyv7vsdY8fpccFF75g",
  "type": "message",
  "role": "assistant",
  "model": "claude-opus-4-1-20250805",
  "content": [
    {
      "type": "text",
      "text": "# CS162 Operating Systems Study Notes\n\n## Lecture 19: File Systems\n\n### Files & Directories\n\n→ Recall: HDDs and SSDs\n\nHDDs require seek + rotation, are not parallel (one head), have brittle moving parts, random reads take 10s milliseconds, are slow (mechanical), but offer cheap/large storage.\n\nSSDs have no seeks, are parallel, have no moving parts, random reads take 10s microseconds, wear out, but offer more expensive/smaller storage.\n\nx Both work better with larger reads & writes\n\n→ Recall: I/O and Storage Layers\n\nHigh level I/O includes streams. Low level I/O includes file descriptors. Syscalls include open(), read(), write(), close(). File system manages files/directories/indexes. I/O driver handles commands and data transfers. Hardware includes disks, flash, controllers, DMA.\n\n→ From Storage to File Systems\n\nVariable-size buffers interface with file system blocks (logical index, typically 4KB). HDDs use sectors (physical index, 512B or 4KB). SSDs use flash translation layer with physical pages (4KB) and erasure blocks.\n\n### Building a File System\n\nFile system is a layer of OS that transforms block interface of disks into files, directories, etc.\n\n→ Purpose of a File System\n\nNaming: Find file by name, not block numbers\nOrganization: Organize file names within directories  \nPlacement: Map files to blocks\nProtection: Enforce access restrictions\nReliability: Keep files intact despite crashes, failures\n\n→ User vs. System View of a File\n\nUser's view: Durable data structures\n\nSystem's view (system call interface): Collection of bytes (UNIX)\n\nSystem's view (inside OS): Collection of blocks (block size ≥ sector size; in UNIX, block size is 4KB)\n\n→ Translation from User to System View\n\nReading bytes 2-12: Fetch block corresponding to those bytes, return just the correct portion\n\nWriting bytes 2-12: Fetch block, modify relevant portion, write out block\n\nx Everything inside file system is in terms of whole-size blocks\n\n→ What Does the File System Need to Do?\n\nTrack free disk blocks (know where to put newly written data)\nTrack which blocks contain data for which files (know where to read from)\nTrack files in a directory (find list of file's blocks given name)\n\nx All maintained somewhere on disk\n\n→ Critical Factors in File System Design\n\n(Hard) Disk Performance\nOpen before read/write\nSize determined as files are used\nOrganized into directories\nNeed to carefully allocate/free blocks\n\n### Files & Directories\n\n→ Manipulating Directories\n\nSystem calls: open/creat/readdir traverse structure, mkdir/rmdir add/remove entries, link/unlink (rm)\n\nlibc support: DIR * opendir, struct dirent * readdir, int readdir_r\n\n→ Example: Early Unix File System\n\nSuperblock object: information about file system\nFree bitmaps: what is allocated/not allocated\nInode object: represents specific file\nDentry object: directory entry, single component of path\nBlocks: How files are stored on disk\nFile object: open file associated with process\n\n→ Components of Unix File System\n\nFile path → Directory Structure → File Header Structure (Inode/\"index node\") → File number \"inumber\" → Data blocks\n\nx One Block = potentially multiple sectors (e.g., 512B sector, 4KB block)\n\n→ How to Find a File's Inode Number?\n\nLook up through directory structure. Directory is specialized file containing <file_name : inode number> mappings. Each mapping called directory entry.\n\n→ File System Workload Characteristics\n\nPublished in FAST 2007\n\nObservation #1: Most Files Are Small\nObservation #2: Most Bytes are in Large Files\n\n### Unix Inode Structure\n\nFile Number is index into array of inode structures. Each inode corresponds to file and contains metadata. Inode maintains multi-level tree to find storage blocks. Original format appeared in BSD 4.1.\n\n→ File Attributes\n\nUser, Group, 9 basic access control bits (UGO x RWX), SetUID bit (execute at owner permissions), SetGID bit (execute at group's permissions)\n\n→ Direct Pointers\n\n12 Direct pointers. 4kB blocks sufficient for files up to 48KB.\n\n→ Indirect Pointers\n\n48 KB + 4 MB + 4 GB + 4 TB\n\nIndirect pointers point to disk block containing only pointers.\n\nAssume 4KB blocks:\n- Maximum size with only direct pointers: 12 * 4 KB = 48 KB\n- Maximum size with one indirect pointer: 12 * 4 KB + 1024 * 4KB = 4.1MB  \n- Maximum size with double indirect pointers: 12 * 4KB + 1024 * 4KB + 1024 * 1024 * 4KB = 4.6 GB\n\n→ Inodes form an on-disk index\n\nSample file in multilevel indexed format (12 direct ptrs, 4K blocks):\n- Block #23 accesses: Two (indirect block, data)\n- Block #5 accesses: One (data)\n- Block #1100 accesses: Three (double indirect block, indirect block, data)\n\n→ Creating new files\n\nInodes stored in inode table. File system stores bitmap of free inodes and free blocks.\n\nOn creating new file:\n1. Check which inode is free/where inode is stored\n2. Check which data blocks are free\n\n### Fast File System (BSD 4.2, 1984)\n\nSame inode structure as BSD 4.1. Changes to block sizes from 1024→4096 bytes for performance.\n\n→ Optimization for Performance and Reliability\n\nDistribute inodes among different tracks closer to data\nUses bitmap allocation in place of freelist\nAttempt to allocate files contiguously\n10% reserved disk space\nSkip-sector positioning\n\n→ FFS Locality: Block Groups\n\nDistribute header information (inodes) closer to data blocks in same \"cylinder group\". File system volume divided into \"block groups\". Data blocks, metadata, and free space interleaved within block group. Put directory and its files in same block group.\n\nFirst-Free allocation of new file blocks. To expand file, first try successive blocks in bitmap, then choose new range. Few little holes at start, big sequential runs at end of group. Avoids fragmentation. Sequential layout for big files.\n\nx Important: keep 10% or more free (reserve space in Block Group)\n\n→ Attack of the Rotational Delay\n\nMissing blocks due to rotational delay. Read one block, do processing, read next block. Disk has continued turning: missed next block. Need 1 revolution/block.\n\nSolution 1: Skip sector positioning (\"interleaving\") - Place blocks from one file on every other block of track\n\nSolution 2: Read-ahead - read next block right after first, even if application hasn't asked yet\n\n→ UNIX 4.2 BSD FFS\n\nPros: Efficient storage for small and large files, Locality for both, No defragmentation necessary\n\nCons: Inefficient for tiny files, Inefficient encoding when file mostly contiguous, Need to reserve 10-20% free space\n\n### Other File Systems\n\n→ FAT (File Allocation Table)\n\nMS-DOS, 1977. File is collection of disk blocks. FAT is linked list 1-1 with blocks. File number is index of root of block list. File offset: block number and offset within block. Follow list to get block number. Unused blocks marked free.\n\nDirectories are files containing <file_name: file_number> mappings. File attributes kept in directory. Each directory has linked list of entries. Root directory always at block 2.\n\n→ Windows NTFS\n\nDefault on modern Windows systems. Variable length extents. Master File Table where everything is sequence of <attribute:value>.\n\nEach MFT entry contains metadata and:\n- File's data directly (small files)\n- List of extents (start block, size) for file's data\n- For big files: pointers to other MFT entries with more extent lists\n\nDirectories implemented as B-Trees. File's number identifies its entry in MFT.\n\n## Lecture 20: File Systems & Reliability\n\n### Buffer Caches\n\nKernel must copy disk blocks to main memory to access contents and write back if modified.\n\n→ Key Idea\n\nExploit temporal locality by caching disk data in memory:\n- Disk blocks: Mapping from block address→disk content\n- Name translations: Mapping from paths→inodes\n\nBuffer Cache: Memory used to cache FS data, including disk blocks and metadata. Can contain \"dirty\" blocks (modifications not on disk).\n\n→ Buffer Cache Replacement Policy\n\nPreferred policy: LRU\n- Can afford overhead full LRU implementation  \n- Works well for name translation\n- Works well if memory accommodates working set\n\nDisadvantages: Fails when application scans through file system, flushing cache with data used once\n\n→ Buffer Cache Size\n\nHow much memory for buffer cache vs virtual memory?\n- Too much to file system cache → won't run many applications\n- Too little to file system cache → applications run slowly\n\nSolution: adjust boundary dynamically to balance disk access rates\n\n→ File System Prefetching\n\nRead Ahead Prefetching: fetch sequential blocks early. Exploit fact that most common file access is sequential. Elevator algorithm can efficiently interleave prefetches.\n\n→ Delayed Writes\n\nBuffer cache is writeback cache. write() copies data from user space to kernel buffer cache (quick return). read() fulfilled by cache.\n\nData reaches disk when:\n- Buffer cache is full (need to evict)\n- Buffer cache flushed periodically (in case of crash)\n\nAdvantages: Low latency, efficient disk scheduling, delay block allocation, some files never reach disk\n\n### Dealing with Persistent State\n\nBuffer cache writes back dirty blocks periodically to minimize data loss. Linux does periodic flush every 30 seconds. Applications can use fsync to force flushing.\n\nx Not foolproof - can still crash with dirty blocks in cache\n\n→ Important \"ilities\"\n\nAvailability: Probability system can accept and process requests\nDurability: Ability to recover data despite faults  \nReliability: Ability to perform required functions under stated conditions for specified time\n\n### Storage Reliability Problem\n\nSingle logical file operation involves updates to multiple physical disk blocks (inode, indirect block, data block, bitmap). At physical level, operations complete one at a time. Want concurrent operations for performance.\n\nx How guarantee consistency regardless of when crash occurs?\n\n→ Threats to Reliability\n\nInterrupted Operation: Crash during related updates may leave data inconsistent\n\nLoss of stored data: Failure of storage media may cause data to disappear/corrupt\n\n### Two Reliability Approaches\n\n1.1 Careful Ordering and Recovery (FAT & FFS + fsck)\n- Each step builds structure: Data block → inode → free → directory\n- Last step links to rest of FS\n- Recovery scans for incomplete actions\n\n1.2 Versioning and Copy-on-Write (ZFS)\n- Version files at some granularity\n- Create new structure linking to unchanged parts\n- Last step declares new version ready\n\n→ Reliability Approach #1: Careful Ordering\n\nSequence operations in specific order. Careful design allows safe interruption. Post-crash recovery reads data structures, cleans up as needed.\n\nBerkeley FFS Create File:\nNormal: Allocate data block, write data, allocate inode, write inode, update bitmaps, update directory, update modify time\n\nRecovery: Scan inode table, delete unlinked files, compare free bitmap against inode trees, scan directories\n\nx Time proportional to disk size\n\n→ Reliability Approach #2: Copy on Write\n\nCreate new version with updated data. Reuse blocks that don't change. Only point to new version when fully done.\n\nx Seems expensive but updates can be batched, disk writes occur in parallel\n\n### Transactions\n\nAtomic sequence of reads and writes taking system from one consistent state to another. Extends atomic updates from memory to persistent storage.\n\n→ Typical Structure\n\nBegin transaction (get transaction id)\nDo updates (roll-back if fail or conflicts)\nCommit transaction\n\n→ Transactional File Systems\n\nBetter reliability through log. Changes treated as transactions. Transaction committed once fully written to log. Data preserved in log and replayed to recover.\n\nDifference: Log Structured filesystem keeps data in log form. Journaled filesystem uses log only for recovery.\n\n→ Journaling File Systems\n\nDon't modify data structures directly. Write each update as transaction in log (journal/intention list). Once in log, safely apply to other structures.\n\nLinux took ext2 and added journal to get ext3.\n\n→ Creating File with Journaling\n\nFind free blocks/inode/dirent → Write to log (map, inode, dirent) → Commit → Eventually replay transaction\n\nAll accesses first look in log (on-disk structure might be stale). Eventually copy to disk and discard from log.\n\n→ Crash Recovery\n\nDiscard Partial: Scan log, detect start with no commit, discard entries, disk unchanged\n\nKeep Complete: Scan log, find start and matching commit, redo as usual\n\n→ Journaling Summary\n\nUpdates atomic even if crash - either fully applied or discarded. All physical operations treated as logical unit.\n\nx Expensive - writing data twice. Modern filesystems journal metadata updates only."
    }
  ],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {
    "input_tokens": 16705,
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "cache_creation": {
      "ephemeral_5m_input_tokens": 0,
      "ephemeral_1h_input_tokens": 0
    },
    "output_tokens": 3096,
    "service_tier": "standard"
  }
}